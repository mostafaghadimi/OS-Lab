
	\سؤال{مشاهده فراخوانی‌های سیستمی تعریف شده}

در این قسمت با توجه به این‌که ساختار سخت‌افزار ما با سوال فرق دارد، فایل \lr{asm} را به کمک دستور \lr{find} پیدا کردیم:

\begin{code}
	> cd /usr/include/
	
	> find . -name asm
	
	./x86_64-linux-gnu/asm
	
	> cd ./x86_64-linux-gnu/asm/
	
	> cat unistd.h
	
\end{code}

\begin{figure}[h!]
	\centering
	\includegraphics[scale=.4]{img/1.png}
\end{figure}

\سؤال{اجرای یک فراخوانی سیستمی}

\begin{itemize}
	\item 
	دستورات زیر را درون \lr{terminal} اجرا می‌کنیم.
	
	\begin{code}
		> mkdir 2 \&\& cd 2
		
		> sudo nano testsyscall.cpp
		
		
	\end{code}

	\item کد داده شده در سوال را در این قسمت کپی کرده و سپس با استفاده از دستور \lr{\lstinline{ctrl + x}} آن را ذخیره می‌کنیم.
	
	\item به کمک دستورات زیر کد را کامپایل کرده و اجرا می‌کنیم.
	
	\begin{code}
		> sudo gcc -o testsyscall testsyscall.cpp 
		
		> ./testsyscall
	\end{code}

	\item نتیجه‌ی اجرای آن ساخته شدن یک پوشه به نام \lr{testdir} در مسیر   \footnote{directory} فعلی است و در آخر پیام \lr{The result is 0.} را چاپ می‌کند.
	
	\item 
	همان‌طور که در توضیحات فراخوانی سیستمی آمده است، هر فراخوانی سیستم با یک شماره‌ی ثابت شناخته می‌شود. نقش \lr{\lstinline{\_\_NR\_mkdir}} (که به‌طور سراسری \footnote{global} تعریف شده است) در این‌جا این است تا عدد مربوط به این فراخوانی جایگرین آن شود.
	
	\begin{figure}[h!]
		\centering
		\includegraphics[scale=.4]{img/2.png}
	\end{figure}
	
	\item تابع \lr{\lstinline{syscall()}} یک تابع کوچک است که رابط زبان \lr{assembly} آن دارای شماره و آرگومان‌های مشخص است. تابع پر کاربردی است اگر از آن بدون \lr{wrapper}ها استفاده کنیم، رجسیترهای پردازنده قبل از فراخوانی سیستم ذخیره می‌کند و بعدا آن‌ها را بازگردانی می‌کند. خروجی آن در صورتی که با موفقیت انجام گیرد، «۰» و در غیر این صورت «۱-» خواهد بود.
\end{itemize}

\سؤال{اجرای ساده‌تر فراخوانی‌های سیستمی}
	
	\begin{Verbatim}[tabsize=4]
#include <stdio.h>
#include <unistd.h>
#include <sys/stat.h>
int main() {
	long result;
	result = mkdir("testdir", 0777);
	printf("The result is %ld.\n", result);
	return 0;
}
	\end{Verbatim}
	
	\سؤال{آشنایی با چند فراخوان سیستمی پرکاربرد}
	\begin{itemize}
		
		\item فراخوان سیستمی \lr{access}
			\begin{Verbatim}[tabsize=4]
#include <errno.h>
#include <stdio.h>
#include <unistd.h>

int main(int argc, char *argv[])
{
	int result;
	char *path = argv[1];
	result = access(path, F_OK);
	if (result == 0)
	{
		printf("%s exists\n", path);
	}
	else
	{
		printf("%s doesn't exist.", path);
	}
	return 0;
}
			\end{Verbatim}
			
		\item فراخوان‌های سیستمی \lr{open, close, write}
		\begin{Verbatim}[tabsize=4]
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>

int main() {
	int open_result;
	int write_result;
	open_result = open("oslab2.txt", O_CREAT | O_WRONLY, 0777);
	write_result = write(open_result, "Mostafa Ghadimi\n", strlen("Mostafa Ghadimi\n"));
	close(open_result);
	return 0;
}

		\end{Verbatim}
		
		\item فراخوان سیستمی \lr{sysinfo}
			\begin{Verbatim}[tabsize=4]

#include <linux/kernel.h>
#include <stdio.h>
#include <sys/sysinfo.h>

int main()
{
	const double megabyte = 1024 * 1024;
	struct sysinfo si;
	sysinfo(&si);
	printf("total RAM: %5.1f MB\n", si.totalram / megabyte);
	printf("free RAM: %5.1f MB\n", si.freeram / megabyte);
	return 0;
}
			\end{Verbatim}
			
		\item فراخوان سیستمی \lr{getrusage}
			\begin{Verbatim}[tabsize=4]
#include <sys/time.h>
#include <sys/resource.h>
#include <stdio.h>

int main() {
	struct rusage ru;
	getrusage(RUSAGE_SELF, &ru);
	printf("maximum resident set size: %ld\n", ru.ru_maxrss);
	printf("integral shared memory size: %ld\n", ru.ru_ixrss);
	printf("integral unshared stack size: %ld\n", ru.ru_isrss);
}
			\end{Verbatim}
	\end{itemize}